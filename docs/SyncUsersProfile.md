If you are building a WeWeb app on top of a Supabase backend, you may be aware that your table of users in Supabase is in a private schema, an `auth` schema And if you want a user to be able to update the profile of another user, that's not possible as is Supabase's recommended approach is to create a `profiles` table in the `public` schema that is synced to the `users` table in the `auth` schema, so that when a new user signs up, a  profile record is also created, which is linked to the `users` table That way, with the profiles in the `public` table, you can allow an admin user for example, to update the information of another user In this video, we'll show you how In Supabase's documentation you can find some of this information in Authorization > Managing User Data Towards the end of the article, we're going to look at the advanced techniques, which is using a trigger so that when  a user signs up and is added to the `users` table in the `auth` schema, we also create a record in the `profiles` table of our `public` schema Let's have a look at our Supabase project By default, when you create a project in Supabase, you have an `auth` schema with a `users` table Here we already have four users because we're already signed up We see there's an email field and there's also this field `raw_user_meta_data` `raw_user_meta_data` which is a JSON with information about the user In this case,  the user signed up with a provider, with their Google account If I copy the cell content and paste it here, I can see the information,  that is available So sub, name, email, a picture, and a full name I have an avatar, URL,  a provider id, custom claims So potentially I might want to get this information for example, or get the user's avatar By default, when you create a project in Supabase, you will not have profiles  table in the public schema, the users table will be in the auth schema and protected But what we can do is first create a profile table, then create a trigger to listen when there's a new user created in the `users` table of the `auth` schema And third, create a function that when that trigger happens, it populates information from the new user in the auth schema to a new profile in the public schema In order to do this, there are several ways The quickest,  way is to go to the "SQL Editor" > "Quickstarts" and "User Management Starter" So what does this say? This is SQL You don't need to be proficient in SQL, but it helps to try to understand what's going on I am not proficient in SQL but there's still a lot of English words and a lot of logical way of presenting the information so hopefully I can understand and you can understand what's going on First, in gray are comments This is not code, this is a description of what is happening The first thing that's happening, this section here is saying create a table that's called `profiles` and the id of each record should be a reference to the `users` table in the `auth` schema And that will be a primary key I want several columns, I want a timestamp that will be called `updated_at` I want a username It will need to be unique, and in Supabase, if you want a field to be unique, you need to add a constraint So here I have a constraint that says the username length needs to be  three or more So I will have a `username` column in this profiles table I will have a `full_name` column, an avatar URL in text, and actually, I don't care about having a website, I'd like an email address I'll just change that So this first block of code will create the `profiles` table for me in the `public` schema I could do this manually using  the Supabase UI with a new table I could do that manually I would just have to make sure that the foreign key is related to the `users` table That would be the most important But for the purposes of this video, we'll do everything in the SQL editor So the second block of code is setting up row level security By default, when you create a new table in Supabase, you want to enable row level security If you don't, it means that everybody will be able to see the data, update the data, create new records, or delete records So you don't want that You want to make sure you enable row level security But once you've enabled row level security, if you don't do anything, if you don't create any policies, then nobody will be able to see any data, nobody will be able to update or create or delete anything So you need to enable security, but you also need to create policies that tell Supabase what people can and cannot do on that table So here we're saying enable row level security on this `profiles` table And then we create three policies All three on the `profiles` table The first one is saying that everybody should  be able to see the profiles Maybe you'll want to change this later and only allow authenticated users to view all the profiles, or to allow users to only see their own profiles You can adjust this later, but this policy is saying public profiles are viewable by everyone This policy here is saying when you are trying to  insert a profile, make sure it's your own profile So here we're checking that the UID of the user in the `auth` schema matches  the ID of the profile in the `profiles` table And it will because here we have this condition Finally we have a third policy saying that we are allowing update if the user is trying to update the profile with the ID that matches the ID of the user who is currently authenticated All right Again, we could  do this manually in Supabase I will show you later how you could edit them But for now, let's do it like this Now, this block here is about creating a trigger, listening for the event of a new user being created in the `users` table of the `auth` schema and using that trigger to go through a function that creates a profile in the `profiles` table So here we have that function that says insert inside the `profiles` table of the `public` schema, you  want to update these three columns: id, full_name, avatar_url and we said earlier we also wanted the email We have to tell the function which values we should input in the profiles table So we want the ID of the new user's record that was created We also want the  full name from the raw user metadata Let's see if we had it here So yeah, we have `full_name` So inside that object we want the value of this key: `full_name` So we'll have to call `raw_user_meta_data` as we saw here  We're saying we want the full name and we also want the avatar url In my users table in the auth schema, I also have an email field, so I can say `new.email`  And this is saying that after a new record is created in the `users` table of the `auth` schema, for each row, we want to execute the `handle_new_user` function, which we wrote here, which is this one Finally here we have information about how to set up storage We don't need to do this for the purposes of this video, so let's keep it at that We will run this and see what happens Let's run it It's a little bit scary, but we will say, okay, "Execute query" and it says "Success" All right, that's a good sign Let's go to our table editor Now we see we have a `profiles` table It's empty because we haven't signed up We haven't created a new record in the `users`  auth table If we have a look at our database, we see the `profiles` table here If we have a look at authentication, we see that  in the policies, if we go to the `profiles` table, we have the three policies that we created So here, for example, we could decide to  change this policy, or we could decide to create a new one We could start from a template So everything that we did in the SQL editor, we could have done here We could have created the policies here Supabase have a few templates like allowing insert access for authenticated users only, for example, or allowing  update access based on a user's email If you're not familiar with SQL, I can only recommend you explore the topic and try learning with the Supabase community that will be helpful to help you write the policy that suits your needs Here in the database, we also have our new trigger: the `on_auth_user_created` after  inserts You can create the trigger manually You would need to say: in the `users` auth table, when there's an insert, you could do an update for example If you want users to be able to update  their user record in the auth schema and you want to update the new information in the profiles table, that's possible with an update trigger In our case, we created an insert trigger after the event, so after someone signs up creates a record in  the `users` table, and for every row Then the function that we triggered was the function `handle_new_user`  We won't confirm because it already exists Here we have our functions with this `handle_new_user` function that says: these are the four columns that I want to update in my `profiles`  table, and I want the values to correspond to this By the way, this needs to be in exactly the same order as this If I had `new.email` here, then the email value would go in the `full_name` column, which is not what I want So again, I will cancel Let's test this Let's go to our WeWeb project and test this I have a sign up workflow here Let's try: joyce+video@weweb.io  I will say "JayKay" it is not my nickname, but hey  Here, if I go on my workflow, I will test it here, and see what happens So let me test this All right  It seems like it worked In Supabase, let's have a look at our `auth` schema and the `users` table: "joyce+video" was created here If I go to my  user metadata, I have the nickname: "JayKay" All right Now if I go to my `profiles` table, I only have the email address Why is that? I actually didn't map anything for the username So if I go to my function `handle_new_user` I could say I also want to update the `username` column And in that case, it will be part of the `raw_user_meta_data` and it will be `nickname` There we go Let's confirm this and let's go back to WeWeb  This time I will say "video2" Let's sign up again There we go Now I have my username So it's called `username` in the `profiles` table, but in the `users` table in the metadata JSON, we see it's called `nickname` That's why in our function, we mapped the `nickname` key of the metadata to the `username` column in our `profiles` table That's it That's how you can create a user profile table in the public schema, of your Supabase back end, and populate that table with new users every time a new user is created in the users table of the private auth schema You want to ensure you add the policies you want so that users can update their own profile Or maybe you want to add a policy so that users with an admin role can update someone else's profile you may also want to trigger a new function when a user updates their user record in the auth  schema The logic will be very similar but will need to be adapted to your specific use case